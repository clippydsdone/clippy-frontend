(function async (Summary) {
    // Summary module start
    // Define module name as constant
    Object.defineProperty(Summary, "name", {
        value: "Summary",
        writable: false
    });

    let content = null;     // Parent div of content to be displayed in sidebar
    let container = null;   // Container for the viewer
    let viewer = null;      // Div of the viewer

    // Initializer method
    Summary.initialize = async function () {
        // TODO: fix this terribleness
        if (Global.isNull(Global.app)) {
            setTimeout(Summary.initialize, 100);
            return;
        } else if (Global.isNull(Global.doc)) {
            setTimeout(Summary.initialize, 100);
            return;
        } else if (Global.isNull(Global.app.documentInfo)) {
            setTimeout(Summary.initialize, 100);
            return;
        }
        console.log("Initializing Summary.");

        // Both are null because we need to wait for the document to load before we can access DOM elements
        content = document.getElementById('summaryView');
        container = document.getElementById('summaryContainer');
        viewer = document.getElementById('summaryViewer');

        await getPaperInfo();
    }

    var BASE64_MARKER = ';base64,';

    function convertDataURIToBinary(dataURI) {
        var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
        var base64 = dataURI.substring(base64Index);
        var raw = window.atob(base64);
        var rawLength = raw.length;
        var array = new Uint8Array(new ArrayBuffer(rawLength));

        for(var i = 0; i < rawLength; i++) {
            array[i] = raw.charCodeAt(i);
        }
        return array;
    }

    let getPdfFullText = async function (){
        doc = window.PDFViewerApplication.pdfDocument;
		let pageTexts = Array.from({length: doc.numPages}, async (v,i) => {
			return (await (await doc.getPage(i+1)).getTextContent()).items.map(token => token.str).join('');
		});
		text = (await Promise.all(pageTexts)).join(' ');
		return text;
    }

    let getPaperInfo = async function () {
        if (Global.isNull(Global.doc)) {
            console.error("PdfDocument object is null. Cannot get pdf data.");
            return;
        }

        const detailsText = document.getElementById("detailsContainerText");
        const loadingBar = document.getElementById("summaryLoadingGif");
        const summaryText = document.getElementById("summaryContainerText");

        let paperTitle = Global.app.documentInfo.Title;
        let result = {};



        let semanticScholarContainer = document.createElement("div");
        summaryText.append(semanticScholarContainer);

        let semanticScholarTitle = document.createElement("h3");
        semanticScholarTitle.innerText = "Semantic Scholar Summary";
        semanticScholarContainer.append(semanticScholarTitle);

        await axios({
            method: 'POST',
            url: 'https://clippyapidev.herokuapp.com/semantic/paper/search',
            data: {
                query: paperTitle
            },
            headers: { 'Content-Type': 'application/json' },
        })
        .then((response) => { 
            result = response.data
            loadingBar.hidden = true;
            if (result && result.tldr && result.tldr.text) {
                semanticScholarContainer.append(document.createTextNode(result.tldr.text));

                semanticScholarContainer.append(document.createElement("br"));
                let semanticScholarDisclaimer = document.createElement("i");
                semanticScholarDisclaimer.innerText = "Disclaimer: This summary was generated by Semantic Scholar."
                semanticScholarContainer.append(semanticScholarDisclaimer);
            } else {
                semanticScholarContainer.append(document.createTextNode("No summary found."));
            }
            Global.data = result;
        })
        .catch((err) => {
            loadingBar.hidden = true;
            semanticScholarContainer.append(document.createTextNode("Paper with title " +  paperTitle + " couldn't be found on Semantic Scholar."));
            result.status = err.response.status;
            result.data = err.message;
            Global.data = {};
        });


        let huggingFaceSummaryContainer = document.createElement("div");
        summaryText.append(huggingFaceSummaryContainer);

        let huggingfaceTitle = document.createElement("h3");
        huggingfaceTitle.innerText = "HuggingFace Summary";
        huggingFaceSummaryContainer.append(huggingfaceTitle);        


        let huggingfaceSummaryButton = document.createElement("button");
        huggingfaceSummaryButton.textContent = "Generate"
        huggingfaceSummaryButton.onclick = async function() {
            try {
                huggingfaceSummaryButton.setAttribute("disabled", true);
                let paperContent = await getPdfFullText();
                
                await axios({
                    method: 'POST',
                    url: 'https://api-inference.huggingface.co/models/facebook/bart-large-cnn',
                    data: {
                        inputs: paperContent,
                        parameters: {
                            min_length: 150,
                            max_length: 400,
                        }
                    },
                    headers: { 'Content-Type': 'application/json' },
                })
                .then((response) => {
                    result = response.data
                    loadingBar.hidden = true;
                    if (result && result[0] && result[0]["summary_text"]) {
                        huggingFaceSummaryContainer.append(document.createTextNode(result[0]["summary_text"]));
    
                        huggingFaceSummaryContainer.append(document.createElement("br"));
                        let huggingFaceDisclaimer = document.createElement("i");
                        huggingFaceDisclaimer.innerText = "Disclaimer: This summary was generated by HuggingFace model bart-large-cnn."
                        huggingFaceSummaryContainer.append(huggingFaceDisclaimer);
                    } else {
                        huggingFaceSummaryContainer.append(document.createTextNode("No summary found."));
                    }
                    Global.data = result;
                })
                .catch((err) => {
                    loadingBar.hidden = true;
                    huggingFaceSummaryContainer.append(document.createTextNode("Paper with title " +  paperTitle + " couldn't be found on Semantic Scholar."));
                    result.status = err.response.status;
                    result.data = err.message;
                    Global.data = {};
                }).finally(() => {
                    huggingFaceSummaryContainer.removeChild(huggingfaceSummaryButton);
                });
            }catch(e){
                huggingFaceSummaryContainer.append(document.createTextNode("Error while parsing PDF text."));
            }            
        }
        huggingFaceSummaryContainer.append(huggingfaceSummaryButton);
                     
        return;
    }

    // Execute initialize method after the document loads
    Clippy.addOnLoadEvent(Summary.name, Summary.initialize);
}(window.Clippy.Summary = window.Clippy.Summary || {}));
